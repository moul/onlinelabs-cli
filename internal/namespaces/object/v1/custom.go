package object

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"reflect"
	"text/template"

	"github.com/scaleway/scaleway-cli/internal/core"
	"github.com/scaleway/scaleway-cli/internal/interactive"
	"github.com/scaleway/scaleway-sdk-go/scw"
)

type s3config struct {
	AccessKey string
	SecretKey string
	Region    string
}

func renderTemplate(configFileTemplate string, c s3config) (string, error) {
	tmpl, err := template.New("configuration").Parse(configFileTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, c)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (c s3config) exportS3cmdConfig() (string, error) {
	configFileTemplate := `# Generated by scaleway-cli command
# Configuration file for s3cmd https://s3tools.org/s3cmd
# Default location: $HOME/.s3cfg
[default]
access_key = {{ .AccessKey }}
bucket_location = {{ .Region }}
host_base = s3.{{ .Region }}.scw.cloud
host_bucket = %(bucket)s.s3.{{ .Region }}.scw.cloud
secret_key = {{ .SecretKey }}
use_https = True`

	return renderTemplate(configFileTemplate, c)
}

func (c s3config) exportRcloneConfig() (string, error) {
	configFileTemplate := `# Generated by scaleway-cli command
# Configuration file for rclone https://rclone.org/s3/#scaleway
# Default location: $HOME/.config/rclone/rclone.conf 
[scaleway_{{ .Region }}]
type = s3
env_auth = false
endpoint = s3.{{ .Region }}.scw.cloud
access_key_id = {{ .AccessKey }}
secret_access_key = {{ .SecretKey }}
region = {{ .Region }}
location_constraint =
acl = private
force_path_style = false
server_side_encryption =
storage_class =`

	return renderTemplate(configFileTemplate, c)
}

func (c s3config) exportMcConfig() (string, error) {
	type hostconfig struct {
		URL       string `json:"url"`
		AccessKey string `json:"accessKey"`
		SecretKey string `json:"secretKey"`
		API       string `json:"api"`
	}
	type mcconfig struct {
		Version string                `json:"version"`
		Hosts   map[string]hostconfig `json:"hosts"`
	}
	m := mcconfig{
		Version: "9",
		Hosts: map[string]hostconfig{
			"scaleway_" + c.Region: {
				URL:       "https://s3." + c.Region + ".scw.cloud",
				AccessKey: c.AccessKey,
				SecretKey: c.SecretKey,
				API:       "S3v2",
			},
		},
	}
	res, err := json.Marshal(m)
	if err != nil {
		return "", nil
	}
	return string(res), nil
}

func GetCommands() *core.Commands {
	return core.NewCommands(
		objectRoot(),
		objectConfig(),
		getCommand(),
		installCommand(),
	)
}

func objectRoot() *core.Command {
	return &core.Command{
		Short:     `Object-storage utils`,
		Namespace: "object",
	}
}

func objectConfig() *core.Command {
	return &core.Command{
		Short:     `Manage configuration files for popular S3 tools`,
		Long:      `Configuration generation for S3 tools.`,
		Namespace: "object",
		Resource:  `config`,
	}
}

func getCommand() *core.Command {
	type getRequest struct {
		Region scw.Region
		Type   string
	}

	return &core.Command{
		Namespace: "object",
		Resource:  "config",
		Verb:      "get",
		Short:     "Generate a S3 related configuration file",
		Long:      "Generate a S3 related configuration file.",
		ArgsType:  reflect.TypeOf(getRequest{}),
		ArgSpecs: []*core.ArgSpec{
			{
				Name:       "type",
				Short:      "Type of tool supported",
				Required:   true,
				EnumValues: []string{"rclone", "s3cmd", "mc"},
			},
			core.RegionArgSpec(scw.RegionFrPar, scw.RegionNlAms),
		},
		Examples: []*core.Example{
			{
				Short: "Generate a s3cmd s3config file for Paris region",
				Raw:   "scw object config install type=s3cmd region=fr-par",
			},
			{
				Short: "Generate a rclone s3config file for default region",
				Raw:   "scw object config install type=rclone",
			},
			{
				Short: "Generate a mc (minio) s3config file for default region",
				Raw:   "scw object config install type=mc",
			},
		},
		SeeAlsos: []*core.SeeAlso{
			{
				Short:   "Install a S3 tool configuration file",
				Command: "scw object config install",
			},
		},
		Run: func(ctx context.Context, argsI interface{}) (interface{}, error) {
			requestedType := argsI.(*getRequest)
			client := core.ExtractClient(ctx)
			region := requestedType.Region.String()
			if region == "" {
				defaultRegion, _ := client.GetDefaultRegion()
				region = defaultRegion.String()
			}
			config := s3config{
				AccessKey: "pouet",
				SecretKey: "pouet",
				Region:    region,
			}

			switch requestedType.Type {
			case "s3cmd":
				res, err := config.exportS3cmdConfig()
				if err != nil {
					return nil, err
				}
				return res, nil
			case "rclone":
				res, err := config.exportRcloneConfig()
				if err != nil {
					return nil, err
				}
				return res, nil
			case "mc":
				res, err := config.exportMcConfig()
				if err != nil {
					return nil, err
				}
				return res, nil
			default:
				fmt.Println("Unknown tool.")
				return nil, nil
			}
		},
	}
}

func installCommand() *core.Command {
	type installRequest struct {
		Region scw.Region
		Type   string
	}
	return &core.Command{
		Namespace: "object",
		Resource:  "config",
		Verb:      "install",
		Short:     "Install a S3 related configuration file to its default location",
		Long:      "Install a S3 related configuration file.",
		ArgsType:  reflect.TypeOf(installRequest{}),
		ArgSpecs: []*core.ArgSpec{
			{
				Name:       "type",
				Short:      "Type of tool supported",
				Required:   true,
				EnumValues: []string{"rclone", "s3cmd", "mc"},
			},
			core.RegionArgSpec(scw.RegionFrPar, scw.RegionNlAms),
		},
		Examples: []*core.Example{
			{
				Short: "Install a s3cmd config file for Paris region",
				Raw:   "scw object config install type=s3cmd region=fr-par",
			},
			{
				Short: "Install a rclone config file for default region",
				Raw:   "scw object config install type=rclone",
			},

			{
				Short: "Install a mc (minio) config file for default region",
				Raw:   "scw object config install type=mc",
			},
		},
		SeeAlsos: []*core.SeeAlso{
			{
				Short:   "Generate a S3 tool configuration file",
				Command: "scw object config get",
			},
		},
		Run: func(ctx context.Context, argsI interface{}) (interface{}, error) {
			requestedType := argsI.(*installRequest)
			client := core.ExtractClient(ctx)
			region := requestedType.Region.String()
			if region == "" {
				defaultRegion, _ := client.GetDefaultRegion()
				region = defaultRegion.String()
			}
			config := s3config{
				AccessKey: "pouet",
				SecretKey: "pouet",
				Region:    region,
			}

			switch requestedType.Type {
			case "s3cmd":
				i, err2 := installS3cmd(config)
				if err2 != nil {
					return i, err2
				}

			case "rclone":
				i, err2 := installRclone(config)
				if err2 != nil {
					return i, err2
				}

			case "mc":
				i, err2 := installMc(config)
				if err2 != nil {
					return i, err2
				}

			default:
				fmt.Println("Unknown tool.")
			}
			return nil, nil
		},
	}
}

func installMc(config s3config) (interface{}, error) {
	newConfig, err := config.exportMcConfig()
	if err != nil {
		return nil, err
	}
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	mcConfigPath := path.Join(homeDir, ".mc", "config.json")
	i, err2, done := ensureFile(mcConfigPath, newConfig)
	if done {
		return i, err2
	}
	return nil, nil
}

func ensureFile(mcConfigPath string, newConfig string) (interface{}, error, bool) {
	// Ask whether to remove previous configuration file if it exists
	if _, err := os.Stat(mcConfigPath); err == nil {
		_, err := interactive.PromptBoolWithConfig(&interactive.PromptBoolConfig{
			Prompt:       "Do you want to overwrite the existing configuration file (" + mcConfigPath + ")?",
			DefaultValue: false,
		})
		if err != nil {
			return "", err, true
		}
		return nil, ioutil.WriteFile(mcConfigPath, []byte(newConfig), 0644), true
	}
	return nil, nil, false
}

func installS3cmd(config s3config) (interface{}, error) {
	newConfig, err := config.exportS3cmdConfig()
	if err != nil {
		return nil, err
	}
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	s3cmdConfigPath := path.Join(homeDir, ".s3cfg")
	i, err2, done := ensureFile(s3cmdConfigPath, newConfig)
	if done {
		return i, err2
	}
	return nil, nil
}

func installRclone(config s3config) (interface{}, error) {
	newConfig, err := config.exportRcloneConfig()
	if err != nil {
		return nil, err
	}
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}
	// `rclone config file` returns the path of the configuration file
	rcloneConfigPath := path.Join(homeDir, ".config", "rclone", "rclone.conf")
	i, err2, done := ensureFile(rcloneConfigPath, newConfig)
	if done {
		return i, err2
	}

	return nil, nil
}
